<!DOCTYPE HTML>
<html lang="en">
<head>
  <title>The Promise of rest-core</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=792, user-scalable=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <link href="https://fonts.googleapis.com/css?family=Roboto+Slab|Oxygen+Mono" rel="stylesheet" type="text/css">
  <link href="../asset/screen-8.4.css" rel="stylesheet" type="text/css">
  <style>
    .avatar{
      width: 56px;
      height: 57px;
      padding-right: 10px;
      vertical-align: middle;
      display: inline-block;
    }
    .date{
      font-family: monospace;
    }
    a:link, a:visited{
      color: teal;
    }
    code{
      background-color: rgba(204, 204, 204, 0.5);
      padding: 0 0.1em 0 0.2em;
      border-radius: 0.5em;
    }
    .lib{
      color: teal;
    }
    .red{
      color: #cf6a4c;
    }
    .blue{
      color: #4b86c2;
    }
    .highlight{
      background-color: #cf6a4c;
      border-radius: 0.3em;
    }
    .fullscreen{
      position: relative;
      top: -87px;
    }
    pre code.lift{
      padding-top: 0.5em;
      padding-bottom: 0.3em;
    }
    .slide > div{
      top: -15px;
      height: 555px;
    }
  </style>
</head>
<body class="list">
  <header class="caption"></header>

<section class="slide shout"><div>
  <h2 style="top:38%; line-height:1em">
    The Promise<br>of
    <a style="border-bottom:none" href="https://github.com/godfat/rest-core">rest-core</a></h2>
  <br><br><br><br><br><br><br><br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  <a href="http://godfat.org/slide/rest-core-promise/">http://godfat.org/slide/2015-01-13-rest-core-promise/</a></span>
</div></section>

<section class="slide"><div>
  <h2>Who?</h2>
  <img class="avatar" src="../asset/spiritual_soul.jpg">
  Lin Jen-Shin (godfat)
  <p>
    <ul><li><span class="date">2001~2004:</span> C</li>
        <li><span class="date">2004~2009:</span> ActionScript</li>
        <li><span class="date">2005~2008:</span> C++</li>
        <li><span class="date">2006~<span class="lib">2015</span>:</span> <span class="red">Ruby</span></li>
        <li><span class="date">2007~<span class="lib">2015</span>:</span> (learning) <span class="blue">Haskell</span></li></ul>
  </p>
</div></section>

<section class="slide shout" style="background-color:#073648"><div>
  <h2>
    <a style="border-bottom:0" href="https://www.codementor.io"><img src="LightningTalk2014RubyConf.png"></a>
  </h2>
</div></section>

<section class="slide"><div>
  <h2>Table of Contents</h2>
  <ul><li class="red">Introduction</li>
      <li>The API / Use Cases</li>
      <li>Streaming, the <code>EventSource</code></li>
      <li>Some Background...</li>
      <li>Concurrency Model</li></ul>
</div></section>

<section class="slide"><div>
  <h2><a href="http://rubyconf.tw/2011/#6">RubyConf.TW 2011</a></h2>
  <ul><li><code class="invisible"></code>rest-core — <a href="http://www.godfat.org/slide/2011-08-27-rest-core.html">A modular Ruby REST client collection/infrastructure</a>
      <li class="next"><code class="invisible"></code>Middleware</li>
      <li class="next"><code class="invisible"></code><a href="https://github.com/godfat/rest-more">rest-more</a></li>
      <li class="next"><code>RestCore::RailsUtilUtil</code></li></ul>
</div></section>

<section class="slide"><div>
  <h2><a href="http://rubyconf.tw/2011/#6">RubyConf.TW 2011</a></h2>
  <ul><li><code class="invisible"></code>rest-core — <a href="https://github.com/godfat/rest-core">Modular Ruby clients interface for REST APIs</a></li>
      <li><code class="invisible"></code>Middleware</li>
      <li><code class="invisible"></code><a href="https://github.com/godfat/rest-more">rest-more</a></li>
      <li><code>RestCore::RailsUtilUtil</code></li>
      <li class="next"><code>RC::Dropbox</code> (via OAuth 1.0a)</li>
      <li class="next"><code>RC::Facebook</code> (via OAuth 2, most completed)</li>
      <li class="next"><code>RC::Github</code> (via OAuth 2)</li>
      <li class="next"><code>RC::Instagram</code> (via OAuth 2)</li></ul>
</div></section>

<section class="slide"><div>
  <h2><a href="http://rubyconf.tw/2011/#6">RubyConf.TW 2011</a></h2>
  <ul><li><code class="invisible"></code>rest-core — <a href="https://github.com/godfat/rest-core">Modular Ruby clients interface for REST APIs</a></li>
      <li><code class="invisible"></code>Middleware</li>
      <li><code class="invisible"></code><a href="https://github.com/godfat/rest-more">rest-more</a></li>
      <li><code>RC::Linkedin</code> (via OAuth 1.0a)</li>
      <li><code>RC::Dropbox</code> (via OAuth 1.0a)</li>
      <li><code>RC::Facebook</code> (via OAuth 2, most completed)</li>
      <li><code>RC::Github</code> (via OAuth 2)</li>
      <li><code>RC::Instagram</code> (via OAuth 2)</li></ul>
</div></section>

<section class="slide"><div>
  <h2><a href="http://rubyconf.tw/2011/#6">RubyConf.TW 2011</a></h2>
  <ul><li><code class="invisible"></code>rest-core — <a href="https://github.com/godfat/rest-core">Modular Ruby clients interface for REST APIs</a></li>
      <li><code class="invisible"></code>Middleware</li>
      <li><code>RC::StackExchange</code> (via OAuth 2)</li>
      <li><code>RC::Linkedin</code> (via OAuth 1.0a)</li>
      <li><code>RC::Dropbox</code> (via OAuth 1.0a)</li>
      <li><code>RC::Facebook</code> (via OAuth 2, most completed)</li>
      <li><code>RC::Github</code> (via OAuth 2)</li>
      <li><code>RC::Instagram</code> (via OAuth 2)</li></ul>
</div></section>

<section class="slide"><div>
  <h2><a href="http://rubyconf.tw/2011/#6">RubyConf.TW 2011</a></h2>
  <ul><li><code class="invisible"></code>rest-core — <a href="https://github.com/godfat/rest-core">Modular Ruby clients interface for REST APIs</a></li>
      <li><code>RC::Twitter</code> (via OAuth 1.0a)</li>
      <li><code>RC::StackExchange</code> (via OAuth 2)</li>
      <li><code>RC::Linkedin</code> (via OAuth 1.0a)</li>
      <li><code>RC::Dropbox</code> (via OAuth 1.0a)</li>
      <li><code>RC::Facebook</code> (via OAuth 2, most completed)</li>
      <li><code>RC::Github</code> (via OAuth 2)</li>
      <li><code>RC::Instagram</code> (via OAuth 2)</li></ul>
</div></section>

<section class="slide"><div>
  <h2><a href="http://rubyconf.tw/2011/#6">RubyConf.TW 2011</a></h2>
  <ul><li>TopCoder: <a href="https://github.com/miaout17/topcoder">topcoder</a></li>
      <li class="next">Plurk: <a href="https://github.com/brucehsu/s2sync_web">s2sync_web</a></li>
      <li class="next">YahooBuy: <a href="https://github.com/GoodLife/rest-more-yahoo_buy">rest-more-yahoo_buy</a></li>
      <li class="next">Firebase: <a href="https://github.com/CodementorIO/rest-firebase">rest-firebase</a></li></ul>
</div></section>

<section class="slide"><div>
  <h2><a href="http://rubyconf.tw/2012/">RubyConf.TW 2012</a></h2>
  <ul><li><a href="http://www.godfat.org/slide/2012-12-07-concurrent.pdf">Concurrent Ruby Application Servers</a></li>
      <li class="next">Linear/Mixed <a href="http://en.wikipedia.org/wiki/Data_dependency">data dependency</a></li>
      <li class="next">Callback/<a href="http://en.wikipedia.org/wiki/Futures_and_promises">Futures</a></li>
      <li class="next"><a href="http://en.wikipedia.org/wiki/CPU-bound">CPU</a> or <a href="http://en.wikipedia.org/wiki/I/O_bound#Comparison_with_CPU-bound">I/O</a> bound</li>
      <li class="next">Unicorn/<a href="http://rainbows.bogomips.org/">Rainbows!</a>/Thin/Puma</li></ul>
</div></section>

<section class="slide"><div>
  <h2>&nbsp;</h2>
  <ul><li>rest-core — <a href="https://github.com/godfat/rest-core">Modular Ruby clients interface for REST APIs</a></li>
      <li>(<span class="red">Middleware</span>) Modular interface for REST clients similar to WSGI/Rack for servers.</li>
      <li class="next">(<span class="red">Promises/Futures</span>) Concurrent requests with synchronous or asynchronous interfaces with threads.</li></ul>
</div></section>

<section class="slide"><div>
  <h2>&nbsp;</h2>
  <ul><li>rest-core — <a href="https://github.com/godfat/rest-core">Modular Ruby clients interface for REST APIs</a></li>
      <li>(<span class="red">Middleware</span>) Modular interface for REST clients similar to WSGI/Rack for servers.</li>
      <li>(<span class="red">Promises/Futures</span>) <span class="blue">Concurrent requests with synchronous or asynchronous interfaces with threads.</span></li></ul>
</div></section>

<section class="slide"><div>
  <h2>Table of Contents</h2>
  <ul><li>Introduction</li>
      <li class="red">The API / Use Cases</li>
      <li>Streaming, the <code>EventSource</code></li>
      <li>Some Background...</li>
      <li>Concurrency Model</li></ul>
</div></section>

<section class="slide"><div>
  <h2>The API / Use Cases</h2>
  <ul><li class="red">Futures / Synchronous / Blocking</li>
      <li>Callbacks / Asynchronous / Non-blocking</li>
      <li>Wait! It's not yet done</li>
      <li>Promise Chain: <code>Promise#then</code></li>
      <li><code>Promise.claim</code></li></ul>
</div></section>

<section class="slide"><div>
  <h1>Futures / Synchronous / Blocking</h1>
  <h2>Print the Name</h2>
  <pre><code class="ruby">
puts client.get('ruby')['name']
  </code></pre>
</div></section>

<section class="slide"><div>
  <h1>Futures / Synchronous / Blocking</h1>
  <h2>Print the Names (Bad)</h2>
  <pre><code class="ruby">
puts client.get('ruby')<span class="highlight">['name']</span> # -- this blocks
puts client.get('opal')['name']</code></pre>
  <span class="next"><h2>Non-blocking (Better)</h2>
  <pre><code class="ruby">
puts %w[ruby opal].map{ |n| client.get(n) }.
                   map{ |r| r['name'] }</code></pre></span>
</div></section>

<section class="slide"><div>
  <h1>Futures / Synchronous / Blocking</h1>
  <h2>Or Easier to Read:</h2>
  <pre><code class="ruby">
a, b = client.get('ruby'), client.get('opal')
puts a['name'], b['name']</code></pre>
  <h2>Non-blocking (Better)</h2>
  <pre><code class="ruby">
puts %w[ruby opal].map{ |n| client.get(n) }.
                   map{ |r| r['name'] }</code></pre>
</div></section>

<section class="slide"><div>
  <h1>Futures / Synchronous / Blocking</h1>
  <h2>Fire and Forget</h2>
  <pre><code class="ruby">
client.post('ruby/cut', style: 'brilliant')</code></pre>
  <span class="next"><h2>Fire and Call</h2>
  <pre><code class="ruby">
client.post('ruby/cut', style: 'brilliant'){}</code></pre></span>
</div></section>

<section class="slide"><div>
  <h2>The API / Use Cases</h2>
  <ul><li>Futures / Synchronous / Blocking</li>
      <li class="red">Callbacks / Asynchronous / Non-blocking</li>
      <li>Wait! It's not yet done</li>
      <li>Promise Chain: <code>Promise#then</code></li>
      <li><code>Promise.claim</code></li></ul>
</div></section>

<section class="slide"><div>
  <h1>Callbacks / Asynchronous / Non-blocking</h1>
  <h2>Fire and Call</h2>
  <pre><code class="ruby">
client.post('ruby/cut', style: 'brilliant'){}


</code></pre>
</div></section>

<section class="slide"><div>
  <h1>Callbacks / Asynchronous / Non-blocking</h1>
  <h2>Fire and Call</h2>
  <pre><code class="ruby">
client.post('ruby/cut', style: 'brilliant') do |r|
  puts r['status']
end</code></pre>
</div></section>

<section class="slide"><div>
  <h1>Callbacks / Asynchronous / Non-blocking</h1>
  <h2>Fire and Rescue</h2>
  <pre><code class="ruby">
client.post('ruby/cut', style: 'brilliant') do |r|
  puts r.kind_of?(Exception)
end</code></pre>
</div></section>

<section class="slide"><div>
  <h1>Callbacks / Asynchronous / Non-blocking</h1>
  <h2>Callback Hell?</h2>
  <pre><code class="ruby">
c = client
%w[ruby opal].each do |n|
  c.get("#{n}/friends") do |f|
    c.get("#{f.first['name']}/friends") do |ff|
      c.post("#{ff.first['name']}/mails", 'Hi')
    end
  end
end</code></pre>
</div></section>

<section class="slide"><div>
  <h1>Callbacks / Asynchronous / Non-blocking</h1>
  <h2>Callback Hell? Eliminate One</h2>
  <pre><code class="ruby">
c = client
%w[ruby opal].each do |n|
  c.get("#{n}/friends") do |f|
    ff = c.get("#{f.first['name']}/friends")
    c.post("#{ff.first['name']}/mails", 'Hi')
  end
end</code></pre>
</div></section>

<section class="slide"><div>
  <h1>Callbacks / Asynchronous / Non-blocking</h1>
  <h2>Callback Hell? But This Blocks!</h2>
  <pre><code class="ruby">
c = client
%w[ruby opal].map do |n|
  c.get("#{n}/friends")
end.map do |f|
  c.get("#{<span class="highlight">f.first</span>['name']}/friends")
end.map do |ff|
  c.post("#{ff.first['name']}/mails", 'Hi')
end</code></pre>
</div></section>

<section class="slide"><div>
  <h1>Callbacks / Asynchronous / Non-blocking</h1>
  <h2>We Still Need Callbacks</h2>
  <a href="http://www.godfat.org/slide/2012-12-07-concurrent.pdf"><img src="data-tmp-01.png" style="position:relative; top:-210px; left:-100px"></a>
</div></section>

<section class="slide"><div>
  <h2>The API / Use Cases</h2>
  <ul><li>Futures / Synchronous / Blocking</li>
      <li>Callbacks / Asynchronous / Non-blocking</li>
      <li class="red">Wait! It's not yet done</li>
      <li>Promise Chain: <code>Promise#then</code></li>
      <li><code>Promise.claim</code></li></ul>
</div></section>

<section class="slide"><div>
  <h1>Wait! It's not yet done</h1>
  <h2><code>RC::Client#wait</code></h2>
  <pre><code class="ruby">
c = client
%w[ruby opal].each do |n|
  c.get("#{n}/friends") do |f|
    ff = c.get("#{f.first['name']}/friends")
    c.post("#{ff.first['name']}/mails", 'Hi')
  end
end


</code></pre>
</div></section>

<section class="slide"><div>
  <h1>Wait! It's not yet done</h1>
  <h2><code>RC::Client#wait</code></h2>
  <pre><code class="ruby">
r = []
%w[ruby opal].each do |n|
  c.get("#{n}/friends") do |f|
    ff = c.get("#{f.first['name']}/friends")
    r &lt;&lt; c.post("#{ff.first['name']}/mails", 'Hi')
  end
end
c.wait       # only for this client instance
puts r</code></pre>
</div></section>

<section class="slide"><div>
  <h1>Wait! It's not yet done</h1>
  <h2><code>RC::Client.wait</code></h2>
  <pre><code class="ruby">
r = []
%w[ruby opal].each do |n|
  c.get("#{n}/friends") do |f|
    ff = c.get("#{f.first['name']}/friends")
    r &lt;&lt; c.post("#{ff.first['name']}/mails", 'Hi')
  end
end
c.class.wait # for all requests from this class
puts r</code></pre>
</div></section>

<section class="slide"><div>
  <h1>Wait! It's not yet done</h1>
  <h2><code>RC::Client.wait</code></h2>
  <pre><code class="ruby">
r = []
%w[ruby opal].each do |n|
  c.get("#{n}/friends") do |f|
    ff = c.get("#{f.first['name']}/friends")
    r &lt;&lt; c.post("#{ff.first['name']}/mails", 'Hi')
  end
end
c.class.wait # useful for gracefully shutdown
puts r</code></pre>
</div></section>

<section class="slide"><div>
  <h2>The API / Use Cases</h2>
  <ul><li>Futures / Synchronous / Blocking</li>
      <li>Callbacks / Asynchronous / Non-blocking</li>
      <li>Wait! It's not yet done</li>
      <li class="red">Promise Chain: <code>Promise#then</code></li>
      <li><code>Promise.claim</code></li></ul>
</div></section>

<section class="slide"><div>
  <h1>Promise Chain: <code>Promise#then</code></h1>
  <h2>Without Waiting... Change This:</h2>
  <pre><code class="ruby">
r = []
%w[ruby opal].each do |n|
  c.get("#{n}/friends") do |f|
    ff = c.get("#{f.first['name']}/friends")
    r &lt;&lt; c.post("#{ff.first['name']}/mails", 'Hi')
  end
end
c.wait
puts r</code></pre>
</div></section>

<section class="slide"><div>
  <h1>Promise Chain: <code>Promise#then</code></h1>
  <h2>Without Waiting... To This:</h2>
  <pre><code class="ruby">
r = %w[ruby opal].map do |n|
  c.get("#{n}/friends", {},
        RC::RESPONSE_KEY => RC::PROMISE).
        then do |res|
    f = res[RC::RESPONSE_BODY]
    ff = c.get("#{f.first['name']}/friends")
    st = c.post("#{ff.first['name']}/mails", 'Hi')
    res.merge(RC::RESPONSE_BODY => st)
  end.future_response[RC::RESPONSE_BODY]
end
puts r</code></pre>
</div></section>

<section class="slide"><div>
  <h1>Promise Chain: <code>Promise#then</code></h1>
  <h2>Why: It's Not Blocking Here</h2>
  <pre><code class="ruby">
r = %w[ruby opal].map do |n|
  c.get("#{n}/friends", {},
        RC::RESPONSE_KEY => RC::PROMISE).
        then do |res|
    f = res[RC::RESPONSE_BODY]
    ff = c.get("#{f.first['name']}/friends")
    st = c.post("#{ff.first['name']}/mails", 'Hi')
    res.merge(RC::RESPONSE_BODY => st)
  end.future_response[RC::RESPONSE_BODY]
end
puts r</code></pre>
</div></section>

<section class="slide"><div>
  <pre class="fullscreen"><code class="ruby">
# <a href="https://github.com/godfat/rest-more/blob/rest-more-3.3.1/lib/rest-core/client/github.rb#L62-L78">RC::Github#all</a>

def all p, query={}, o={}
  q = {:per_page => MAX_PER_PAGE}.merge(query)
  r = <span class="highlight">get</span>(p, q, o.merge(RESPONSE_KEY => PROMISE)).
      then{ |res|
    b = res[RESPONSE_BODY] +
        page_range(res).<span class="highlight">map</span>{ |page|
          <span class="highlight">get</span>(p, q.merge(:page => page),
            o.merge(RESPONSE_KEY=>RESPONSE_BODY))
        }.inject([], &amp;:+)
    res.merge(RESPONSE_BODY => b)
  }.future_response
  if block_given?
    yield(r[response_key(o)]); self
  else
    r[response_key(o)]
  end
end</code></pre>
</div></section>

<section class="slide"><div>
  <h2>The API / Use Cases</h2>
  <ul><li>Futures / Synchronous / Blocking</li>
      <li>Callbacks / Asynchronous / Non-blocking</li>
      <li>Wait! It's not yet done</li>
      <li>Promise Chain: <code>Promise#then</code></li>
      <li class="red"><code>Promise.claim</code></li></ul>
</div></section>

<section class="slide"><div>
  <h1><code>Promise.claim</code></h1>
  <h2>Forging Response,<br>for middleware <code>RC::Cache</code></h2>
  <pre><code class="ruby">
RC::Promise.
  claim(res, k, body, 200, 'Header' => 'Here').
  future_response</code></pre>
</div></section>

<section class="slide"><div>
  <h1><code>Promise.claim</code></h1>
  <h2>Forging Response,<br>for middleware <code>RC::Cache</code></h2>
  <pre><code class="ruby">
def RC::Promise.claim env, k=RC.id,
                      body, status, headers
  promise = new(env, k)
  promise.fulfill(body, status, headers)
  promise
end</code></pre>
</div></section>

<section class="slide"><div>
  <h2>Table of Contents</h2>
  <ul><li>Introduction</li>
      <li>The API / Use Cases</li>
      <li class="red">Streaming, the <code>EventSource</code></li>
      <li>Some Background...</li>
      <li>Concurrency Model</li></ul>
</div></section>

<section class="slide"><div>
  <h2>Streaming, the <code>EventSource</code></h2>
  <ul><li class="red">SSE, Server-Sent Events</li>
      <li class="red">SSE with Rack Hijacking</li>
      <li>Firebase Daemon (rest-firebase)</li></ul>
</div></section>

<section class="slide"><div>
  <h1>Streaming, the <code>EventSource</code></h1>
  <h2><a href="http://en.wikipedia.org/wiki/Server-sent_events">SSE, Server-Sent Events</a></h2>
  <blockquote>is a technology where a browser receives automatic updates from a server via HTTP connection. The <span class="red">Server-Sent Events</span> <code>EventSource</code> API is standardized as part of <span class="red">HTML5</span> by the W3C.</blockquote>
  <br><h2 style="text-align: right">Said Wikipedia.</h2>
</div></section>

<section class="slide"><div>
  <h1>Streaming, the <code>EventSource</code></h1>
  <h2><a href="http://en.wikipedia.org/wiki/Server-sent_events">SSE, Server-Sent Events</a></h2>
  <pre><code class="javascript">
var source = new EventSource('/api/sse');
source.onmessage = function (event) {
  console.log(event.data);
};</code></pre>
</div></section>

<section class="slide"><div>
  <h1>Streaming, the <code>EventSource</code></h1>
  <h2>SSE with <a href="http://www.rubydoc.info/github/rack/rack/file/SPEC#Hijacking">Rack Hijacking</a></h2>
  <pre><code class="ruby">
get '/api/sse' do # (<a href="https://github.com/godfat/saya/commit/0bfb3bd470f70e20ca77d8cf3b47d1613c324a87">jellyfish's</a>/<a href="https://gist.github.com/raggi/ff7971991297e5c8a1ce">raggi's</a> example)
  headers_merge(
    'Content-Type' => 'text/event-stream',
    'rack.hijack'  => lambda do |io|
      loop do
        io.write("data: Aloha!\n\n")
        sleep 5
      end
    end)
end</code></pre>
</div></section>

<section class="slide"><div>
  <h2>Streaming, the <code>EventSource</code></h2>
  <ul><li>SSE, Server-Sent Events</li>
      <li>SSE with Rack Hijacking</li>
      <li class="red">Firebase Daemon (rest-firebase)</li></ul>
</div></section>

<section class="slide"><div>
  <h1>Streaming, the <code>EventSource</code></h1>
  <h2><a href="https://github.com/CodementorIO/rest-firebase/blob/30b7c3308ca446c090d1dd8bfa925ad85ae461e7/example/daemon.rb">Firebase Daemon</a> (rest-firebase)</h2>
  <pre><code class="ruby">
require 'rest-firebase'

es = RestFirebase.new(auth: false).event_source(
       'https://SampleChat.firebaseIO-demo.com/')</code></pre>
</div></section>

<section class="slide"><div>
  <h1>Streaming, the <code>EventSource</code></h1>
  <h2><a href="https://github.com/CodementorIO/rest-firebase/blob/30b7c3308ca446c090d1dd8bfa925ad85ae461e7/example/daemon.rb">Firebase Daemon</a> (rest-firebase)</h2>
  <pre><code class="ruby">
es.onerror do |error|
  puts "ERROR: #{error}"
end

es.onreconnect do
  !!@start # always reconnect unless stopping
end

es.onmessage do |event, data|
  puts "EVENT: #{event}, DATA: #{data}"
end</code></pre>
</div></section>

<section class="slide"><div>
  <h1>Streaming, the <code>EventSource</code></h1>
  <h2><a href="https://github.com/CodementorIO/rest-firebase/blob/30b7c3308ca446c090d1dd8bfa925ad85ae461e7/example/daemon.rb">Firebase Daemon</a> (rest-firebase)</h2>
  <pre><code class="ruby">
@start = true
es.start

rd, wr = IO.pipe
Signal.trap('INT') do # intercept ctrl-c
  @start = false      # stop reconnecting
  es.close            # close socket
  es.wait             # wait for shutting down
  wr.puts             # unblock main thread
end
rd.gets               # main thread blocks here</code></pre>
</div></section>

<section class="slide"><div>
  <h1>Streaming, the <code>EventSource</code></h1>
  <h2><a href="https://github.com/CodementorIO/rest-firebase/blob/30b7c3308ca446c090d1dd8bfa925ad85ae461e7/example/daemon.rb">Firebase Daemon</a> (rest-firebase)</h2>
  <pre><code class="bash">
curl <span class="hljs-operator">-X</span> POST -d '{"message": "Hi!"}' \
https://SampleChat.firebaseIO-demo.com/ruby.json</code></pre>
  <pre class="next"><code>
EVENT: put, DATA:
  {"path"=>"/ruby/-JfOWDn1LQJn-ng9EcF6",
   "data"=>{"message"=>"Hi!"}}</code></pre>
</div></section>

<section class="slide"><div>
  <h2>Table of Contents</h2>
  <ul><li>Introduction</li>
      <li>The API / Use Cases</li>
      <li>Streaming, the <code>EventSource</code></li>
      <li class="red">Some Background...</li>
      <li>Concurrency Model</li></ul>
</div></section>

<section class="slide"><div>
  <h2>Some Background...</h2>
  <ul><li class="red">Race Conditions</li>
      <li class="red"><code>Mutex</code> (mutual exclusion) (lock)</li>
      <li><code>ConditionVariable</code> (monitor)</li></ul>
</div></section>

<section class="slide"><div>
  <h2><code class="invisible"></code><a href="http://en.wikipedia.org/wiki/Race_condition">Race Conditions</a></h2>
  <pre><code class="ruby">
@i = 0         #
#---thread a---#---thread b-----

  tmp = @i
  @i  = tmp + 1


                   tmp = @i
                   @i  = tmp + 1

# -------------#----------------
@i # =&gt; 2      #</code></pre>
</div></section>

<section class="slide"><div>
  <h2><code class="invisible"></code><a href="http://en.wikipedia.org/wiki/Race_condition">Race Conditions</a></h2>
  <pre><code class="ruby">
@i = 0         #
#---thread a---#---thread b-----

  tmp = @i

                   tmp = @i
  @i  = tmp + 1

                   @i  = tmp + 1

# -------------#----------------
@i # =&gt; 2      #</code></pre>
</div></section>

<section class="slide"><div>
  <h2><code>Mutex</code> (<a href="http://en.wikipedia.org/wiki/Lock_%28computer_science%29">lock</a>)</h2>
  <pre><code class="ruby">
@i = 0         #
#---thread a---#---thread b-----
synchronize do
  tmp = @i
  @i  = tmp + 1
end
                 synchronize do
                   tmp = @i
                   @i  = tmp + 1
                 end
# -------------#----------------
@i # =&gt; 2      #</code></pre>
</div></section>

<section class="slide"><div>
  <h2>Some Background...</h2>
  <ul><li>Race Conditions</li>
      <li><code>Mutex</code> (mutual exclusion) (lock)</li>
      <li class="red"><code>ConditionVariable</code> (monitor)</li></ul>
</div></section>

<section class="slide"><div>
  <h2><code>ConditionVariable</code> (<a href="http://en.wikipedia.org/wiki/Monitor_%28synchronization%29">monitor</a>)</h2>
  <pre><code class="ruby">
#---thread a---#---thread b----------------------
synchronize do # &lt;= a acquires lock
  condv.wait   # &lt;= a releases lock and sleeps
                 synchronize do # b acquires lock
                   @i = 1
                   condv.signal # a wakes up
                 end            # b releases lock
               # &lt;= a acquires lock
  puts @i      # =&gt; 1
end            # &lt;= a releases lock</code></pre>
</div></section>

<section class="slide"><div>
  <h2>Table of Contents</h2>
  <ul><li>Introduction</li>
      <li>The API / Use Cases</li>
      <li>Streaming, the <code>EventSource</code></li>
      <li>Some Background...</li>
      <li class="red">Concurrency Model</li></ul>
</div></section>

<section class="slide"><div>
  <h2>Concurrency Model</h2>
  <ul><li>None / Blocking (<span class="blue">For debugging purpose</span>)</li>
      <li>Thread Spawn (<span class="blue">Default</span>)</li>
      <li>Thread Pool (<span class="blue">Throttling</span>)</li></ul>
</div></section>

<section class="slide"><div>
  <h2>Concurrency Model</h2>
  <ul><li class="red">Gotcha!</li>
      <li><code>Promise</code> Detail</li>
      <li><code>ThreadPool</code> Detail</li></ul>
</div></section>

<section class="slide"><div>
  <h1>Concurrency Model</h1>
  <h2>Gotcha!</h2>
  <ul><li class="red">Weird Backtrace for Exceptions</li>
      <li>Shutting Down Gracefully</li>
      <li>Beware of Deadlock!</li>
      <li>Beware of Timeout!</li>
      <li>Inaccurate Timeout</li></ul>
</div></section>

<section class="slide"><div>
  <h2>Weird Backtrace for Exceptions</h2>
  <pre><code class="ruby">
def f n=1
  if n.zero?
    # Thread.new do
      raise '' rescue p $!.backtrace
    # end.join
  else
    f(n-1)
  end
end
f # => ["-:4:in `f'", "-:7:in `f'",
  #     "-:10:in `&lt;main&gt;'"]</code></pre>
</div></section>

<section class="slide"><div>
  <h2>Weird Backtrace for Exceptions</h2>
  <pre><code class="ruby">
def f n=1
  if n.zero?
    Thread.new do
      raise '' rescue p $!.backtrace
    end.join
  else
    f(n-1)
  end
end
f # => <span class="next">["-:4:in `block in f'"]</span>
  #</code></pre>
</div></section>

<section class="slide"><div>
  <h1>Retaining Backtrace to Ease Debugging</h1>
  <pre><code class="ruby">
def defer
  if pool_size &lt; 0 # none / blocking
  else
    # retain the backtrace so far
    <span class="highlight">backtrace</span> = caller + self.class.backtrace
    if pool_size &gt; 0 # thread pool
    else
      self.thread = Thread.new do
        Thread.current[:backtrace] = <span class="highlight">backtrace</span>
        protected_yield{ yield }
      end
    end
  end
end</code></pre>
</div></section>

<section class="slide"><div>
  <h1>Retaining Backtrace to Ease Debugging</h1>
  <ul><li>Not always correct</li>
      <li>Might be weird for <code>ThreadPool</code></li>
      <li>Just some hints!</li>
      <li>Could consume a bit memory given large call stacks</li></ul>
</div></section>

<section class="slide"><div>
  <h1>Concurrency Model</h1>
  <h2>Gotcha!</h2>
  <ul><li>Weird Backtrace for Exceptions</li>
      <li class="red">Shutting Down Gracefully</li>
      <li>Beware of Deadlock!</li>
      <li>Beware of Timeout!</li>
      <li>Inaccurate Timeout</li></ul>
</div></section>

<section class="slide"><div>
  <h1>&nbsp;</h1>
  <pre class="fullscreen"><code class="ruby">
at_exit do
  RC::Universal.shutdown
end

def shutdown # RC::Client.shutdown
  thread_pool.shutdown
  wait
end

def shutdown # RC::ThreadPool#shutdown
  workers.size.times{ trim(true) }
  workers.first.join &amp;&amp; trim(true) until
    workers.empty?
  queue.clear
end</code></pre>
</div></section>

<section class="slide"><div>
  <h1>Concurrency Model</h1>
  <h2>Gotcha!</h2>
  <ul><li>Weird Backtrace for Exceptions</li>
      <li>Shutting Down Gracefully</li>
      <li class="red">Beware of Deadlock!</li>
      <li class="red">Beware of Timeout!</li>
      <li>Inaccurate Timeout</li></ul>
</div></section>

<section class="slide"><div>
  <h1>Beware of Deadlock!</h1>
  <pre><code class="ruby">
RC::Universal.pool_size = 1
client = RC::Universal.new
client.get('ruby/friends') do |response|
  path = "#{response.first['name']}/friends"
  puts client.get(path).first['name']
end</code></pre>
</div></section>

<section class="slide"><div>
  <h1>Beware of Deadlock!</h1>
  <pre><code class="ruby">
RC::Universal.pool_size = 1
client = RC::Universal.new
client.get('ruby/friends') do |response|
  path = "#{response.first['name']}/friends"
  puts client.get(path)<span class="highlight">.first</span>['name'] # DEADLOCK!
end</code></pre>
  <h2>Need at least two threads!</h2>
</div></section>

<section class="slide"><div>
  <h1>Beware of Timeout!</h1>
  <pre><code class="ruby">
RC::Universal.pool_size = 1
client = RC::Universal.new(:timeout => 10)
client.get('ruby/friends') do |response|
  path = "#{response.first['name']}/friends"
  puts client.get(path)<span class="highlight">.first</span>['name'] # DEADLOCK!
end</code></pre>
  <h2>Raise timeout in this case</h2>
</div></section>

<section class="slide"><div>
  <h1>Beware of Timeout!</h1>
  <pre><code class="ruby">
RC::Universal.pool_size = 1
client = RC::Universal.new(:timeout => 10)

1000.times do |i|
  client.get("ruby/#{i}"){ |res| puts res }
end</code></pre>
  <h2>If the request needs &gt; <code>10ms</code></h2>
</div></section>

<section class="slide"><div>
  <h1>Beware of Timeout!</h1>
  <pre><code class="ruby">
RC::Universal.pool_size = 10
client = RC::Universal.new(:timeout => 10)

1000.times do |i|
  client.get("ruby/#{i}"){ |res| puts res }
end</code></pre>
  <h2>If the request needs &gt; <code>100ms</code></h2>
</div></section>

<section class="slide"><div>
  <h1>Concurrency Model</h1>
  <h2>Gotcha!</h2>
  <ul><li>Weird Backtrace for Exceptions</li>
      <li>Shutting Down Gracefully</li>
      <li>Beware of Deadlock!</li>
      <li>Beware of Timeout!</li>
      <li class="red">Inaccurate Timeout</li></ul>
</div></section>

<section class="slide"><div>
  <h1>Inaccurate Timeout</h1>
  <ul><li>Single threaded (<span class="red">timeout.rb</span> uses a thread for each task)</li>
      <li>Auto-shutting down</li>
      <li>Check per <code>Timer.interval</code> (thus inaccurate)</li></ul>
  <span class="next"><h2>Increase Polling Interval</h2>
  <pre><code class="ruby">
RC::Timer.interval = 0.5 # Default 1 second</code></pre></span>
</div></section>

<section class="slide"><div>
  <h2>Concurrency Model</h2>
  <ul><li>Gotcha!</li>
      <li class="red"><code>Promise</code> Detail</li>
      <li><code>ThreadPool</code> Detail</li></ul>
</div></section>

<section class="slide"><div>
  <h1>Concurrency Model</h1>
  <h2><code>Promise</code> Detail</h2>
  <ul><li class="red"><code>Promise#defer</code></li>
      <li><code>Promise#protected_yield</code></li>
      <li><code>Promise#cancel_task</code></li></ul>
</div></section>

<section class="slide"><div>
  <h1>Concurrency Model - None / Blocking (For debugging purpose)</h1>
  <pre><code class="ruby lift">RC::Universal.pool_size = -1

<span class="next">def defer
  if pool_size &lt; 0
    # set working thread
    self.thread = Thread.current
    # avoid any exception and do the job
    protected_yield{ yield }
  else
    # ...
  end
end</span></code></pre>
</div></section>

<section class="slide"><div>
  <h1>Concurrency Model - Thread Spawn (default)</h1>
  <pre><code class="ruby lift">RC::Universal.pool_size =  0
<span class="next">def defer
  if pool_size &lt; 0 # none / blocking
  else
    # retain the backtrace so far
    backtrace = caller + self.class.backtrace
    if pool_size &gt; 0 # thread pool
    else
      self.thread = Thread.new do
        Thread.current[:backtrace] = backtrace
        protected_yield{ yield }
      end
    end
  end
end</span></code></pre>
</div></section>

<section class="slide"><div>
  <h1>Concurrency Model - Thread Pool (Throttling)</h1>
  <pre><code class="ruby lift">RC::Universal.pool_size = 10</code></pre>
  <ul><li>For limited database or HTTP connection</li></ul>
</div></section>

<section class="slide"><div>
  <h1>Concurrency Model - Thread Pool (Throttling)</h1>
  <pre><code class="ruby lift">if pool_size &gt; 0
  mutex.synchronize do
    # still timing it out if the task
    # never processed
    env[TIMER].on_timeout{cancel_task}
      if env[TIMER]
    self.task = client_class.thread_pool.
      defer(mutex) do
        Thread.current[:backtrace] = backtrace
        protected_yield{ yield }
        Thread.current[:backtrace] = nil
      end
  end
else # thread spawn
end</code></pre>
</div></section>

<section class="slide"><div>
  <pre class="fullscreen"><code class="ruby lift">def defer
  if pool_size &lt; 0 # negative number for blocking call
    self.thread = Thread.current # set working thread
    protected_yield{ yield } # avoid any exception and do the job
  else
    backtrace = caller + self.class.backtrace # retain the backtrace so far
    if pool_size &gt; 0
      mutex.synchronize do
        # still timing it out if the task never processed
        env[TIMER].on_timeout{ cancel_task } if env[TIMER]
        self.task = client_class.thread_pool.defer(mutex) do
          Thread.current[:backtrace] = backtrace
          protected_yield{ yield }
          Thread.current[:backtrace] = nil
        end
      end
    else
      self.thread = Thread.new do
        Thread.current[:backtrace] = backtrace
        protected_yield{ yield }
      end
    end
  end
end</code></pre>
</div></section>

<section class="slide"><div>
  <h1>Concurrency Model</h1>
  <h2><code>Promise</code> Detail</h2>
  <ul><li><code>Promise#defer</code></li>
      <li class="red"><code>Promise#protected_yield</code></li>
      <li><code>Promise#cancel_task</code></li></ul>
</div></section>

<section class="slide"><div>
  <pre class="fullscreen"><code class="ruby lift">def protected_yield
  if env[TIMER]
    timeout_protected_yield{ yield }
  else
    yield
  end
rescue Exception => e # could be Timeout::Error
  mutex.synchronize do
    self.class.set_backtrace(e)
    if done? # log user callback error
      callback_error(e)
    else # IOError, SystemCallError, etc
      begin
        rejecting(e) # would call user callback
      rescue Exception => f
        callback_error(f)# log user callback error
      end
    end
  end
end</code></pre>
</div></section>

<section class="slide"><div>
  <h1><code>Promise#timeout_protected_yield</code></h1>
  <pre><code class="ruby">
def timeout_protected_yield
  # timeout might already be set for
  # thread_pool (pool_size > 0)
  env[TIMER].on_timeout{ cancel_task } unless
    env[TIMER].timer
  yield
ensure
  env[TIMER].cancel
end</code></pre>
</div></section>

<section class="slide"><div>
  <h1>Concurrency Model</h1>
  <h2><code>Promise</code> Detail</h2>
  <ul><li><code>Promise#defer</code></li>
      <li><code>Promise#protected_yield</code></li>
      <li class="red"><code>Promise#cancel_task</code></li></ul>
</div></section>

<section class="slide"><div>
  <pre class="fullscreen"><code class="ruby">
def cancel_task bt=nil
  mutex.synchronize do
    next if done? # don't cancel if it's done
    if t = thread || task.thread
      # raise Timeout::Error to working thread
      t.raise(env[TIMER].error)
    else # task was queued and never started,
      begin # just cancel it and fulfil the
        task.cancel # promise with Timeout::Error
        rejecting(env[TIMER].error)
      rescue Exception => e
        # log user callback error
        callback_error(e) do
          e.set_backtrace(e.backtrace + (bt||[]))
        end
      end
    end
  end
end</code></pre>
</div></section>

<section class="slide"><div>
  <h2>Concurrency Model</h2>
  <ul><li>Gotcha!</li>
      <li><code>Promise</code> Detail</li>
      <li class="red"><code>ThreadPool</code> Detail</li></ul>
</div></section>

<section class="slide"><div>
  <h1>Concurrency Model</h1>
  <h2><code>ThreadPool</code> Detail</h2>
  <ul><li class="red"><code>ThreadPool#defer</code></li>
      <li><code>ThreadPool#spawn_worker</code></li>
      <li><code>ThreadPool::Task</code></li></ul>
</div></section>

<section class="slide"><div>
  <h1>Concurrency Model - <code>ThreadPool#defer</code></h1>
  <pre><code class="ruby">
def defer mutex=nil, &amp;job
  task = Task.new(job, mutex)
  <span class="highlight">queue</span> &lt;&lt; task
  spawn_worker if waiting == 0 &amp;&amp;
                  workers.size &lt; <span class="highlight">max_size</span>
  task
end</code></pre>
</div></section>

<section class="slide"><div>
  <h1>Concurrency Model</h1>
  <h2><code>ThreadPool</code> Detail</h2>
  <ul><li><code>ThreadPool#defer</code></li>
      <li class="red"><code>ThreadPool#spawn_worker</code></li>
      <li><code>ThreadPool::Task</code></li></ul>
</div></section>

<section class="slide"><div>
  <h1>Concurrency Model - <code>ThreadPool#spawn_worker</code></h1>
  <pre><code class="ruby">
def spawn_worker
  workers &lt;&lt; Thread.new{
    task = nil
    begin
      mutex.synchronize{ @waiting += 1 }
      task = <span class="highlight">queue</span>.pop(idle_time)
      mutex.synchronize{ @waiting -= 1 }
    end while <span class="highlight">task</span>.call(Thread.current)
    mutex.synchronize do
      workers.delete(Thread.current)
    end
  }
end</code></pre>
</div></section>

<section class="slide"><div>
  <h1>Concurrency Model</h1>
  <h2><code>ThreadPool</code> Detail</h2>
  <ul><li><code>ThreadPool#defer</code></li>
      <li><code>ThreadPool#spawn_worker</code></li>
      <li class="red"><code>ThreadPool::Task</code></li></ul>
</div></section>

<section class="slide"><div>
  <h1>Concurrency Model - <code>ThreadPool::Task</code></h1>
  <pre><code class="ruby">
class Task &lt; Struct.new(:job, :mutex, :thread,
                        :cancelled)
  # this should never fail
  def call working_thread
    mutex.synchronize do
      return if cancelled
      self.<span class="highlight">thread</span> = working_thread
    end
    job.call
    true
  end
  # we should probably synchronize this, too!
  def cancel; self.cancelled = true; end
end</code></pre>
</div></section>

<section class="slide"><div>
  <h2>Bibliography</h2>
  <ul><li><a href="https://gist.github.com/godfat/2592f9ecf95f38d7f819">Outline</a></li>
      <li><a href="http://www.meetup.com/rails-taiwan/events/219273897/">Rails Tuesday Sharing #8</a></li>
      <li><a href="http://www.w3.org/TR/eventsource/">Server-Sent Events</a></li>
      <li><a href="http://chimera.labs.oreilly.com/books/1230000000929/ch09.html">Parallel and Concurrent Programming in Haskell:<br>Chapter 9. Cancellation and Timeouts</a></li>
      <li><a href="http://headius.blogspot.tw/2008/02/rubys-threadraise-threadkill-timeoutrb.html">Ruby's Thread#raise, Thread#kill, timeout.rb,<br>and net/protocol.rb libraries are broken</a> (2008)</li></ul>
</div></section>

<section class="slide shout"><div>
<h2>Q?</h2>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="https://github.com/godfat/rest-core">https://github.com/godfat/rest-core</a>
<br><br><br><br><br><br>
<pre><code class="ruby" style="text-align:center">
<span class="red">gem</span> <span class="hljs-string">install</span> <span class="hljs-constant">rest-core</span></code></pre>
</div></section>

  <div class="progress"><div></div></div>
  <script src="../asset/shower.min.js"></script>
  <script src='../asset/highlight-8.4.pack.js' type='text/javascript'></script>
  <script>hljs.initHighlightingOnLoad();</script>
</body>
</html>
