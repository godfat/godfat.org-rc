<!DOCTYPE HTML>
<html lang="en">
<head>
  <title>The Promise of rest-core</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=792, user-scalable=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <link href="https://fonts.googleapis.com/css?family=Roboto+Slab|Oxygen+Mono" rel="stylesheet" type="text/css">
  <link href="../asset/screen.css" rel="stylesheet" type="text/css">
  <style>
    .avatar{
      width: 56px;
      height: 57px;
      padding-right: 10px;
      vertical-align: middle;
      display: inline-block;
    }
    .date{
      font-family: monospace;
    }
    a:link, a:visited{
      color: teal;
    }
    code{
      background-color: rgba(204, 204, 204, 0.5);
      padding: 0 0.1em 0 0.2em;
      border-radius: 0.5em;
    }
    .lib{
      color: teal;
    }
    .red{
      color: #cf6a4c;
    }
    .blue{
      color: #4b86c2;
    }
    .highlight{
      background-color: #cf6a4c;
    }
    .fullscreen{
      position: relative;
      top: -100px;
    }
  </style>
</head>
<body class="list">
  <header class="caption"></header>

<section class="slide shout"><div>
  <h2 style="top:38%; line-height:1em">
    The Promise<br>of
    <a style="border-bottom:none" href="https://github.com/godfat/rest-core">rest-core</a></h2>
  <br><br><br><br><br><br><br><br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  <a href="http://godfat.org/slide/rest-core-promise/">http://godfat.org/slide/2015-01-13-rest-core-promise/</a></span>
</div></section>

<section class="slide"><div>
  <h2>Who?</h2>
  <img class="avatar" src="../asset/spiritual_soul.jpg">
  Lin Jen-Shin (godfat)
  <p>
    <ul><li><span class="date">2001~2004:</span> C</li>
        <li><span class="date">2004~2009:</span> ActionScript</li>
        <li><span class="date">2005~2008:</span> C++</li>
        <li><span class="date">2006~<span class="lib">2015</span>:</span> <span class="red">Ruby</span></li>
        <li><span class="date">2007~<span class="lib">2015</span>:</span> (learning) <span class="blue">Haskell</span></li></ul>
  </p>
</div></section>

<section class="slide shout" style="background-color:#073648"><div>
  <h2>
    <a style="border-bottom:0" href="https://www.codementor.io"><img src="LightningTalk2014RubyConf.png"></a>
  </h2>
</div></section>

<section class="slide"><div>
  <h2>Table of Contents</h2>
  <ul><li class="red">Introduction</li>
      <li>The API / Use Cases</li>
      <li>Concurrency Model</li>
      <li>Streaming, the EventSource</li>
      <li>The Timeout Quest</li></ul>
</div></section>

<section class="slide"><div>
  <h2><a href="http://rubyconf.tw/2011/#6">RubyConf.TW 2011</a></h2>
  <ul><li>rest-core — <a href="http://www.godfat.org/slide/2011-08-27-rest-core.html">A modular Ruby REST client collection/infrastructure</a>
      <li class="next">Middleware</li>
      <li class="next"><a href="https://github.com/godfat/rest-more">rest-more</a></li>
      <li class="next">RestCore::RailsUtilUtil</li></ul>
</div></section>

<section class="slide"><div>
  <h2><a href="http://rubyconf.tw/2011/#6">RubyConf.TW 2011</a></h2>
  <ul><li>rest-core — <a href="https://github.com/godfat/rest-core">Modular Ruby clients interface for REST APIs</a></li>
      <li>Middleware</li>
      <li><a href="https://github.com/godfat/rest-more">rest-more</a></li>
      <li>RestCore::RailsUtilUtil</li>
      <li class="next">RC::Dropbox (via OAuth 1.0a)</li>
      <li class="next">RC::Facebook (via OAuth 2, most completed)</li>
      <li class="next">RC::Github (via OAuth 2)</li>
      <li class="next">RC::Instagram (via OAuth 2)</li></ul>
</div></section>

<section class="slide"><div>
  <h2><a href="http://rubyconf.tw/2011/#6">RubyConf.TW 2011</a></h2>
  <ul><li>rest-core — <a href="https://github.com/godfat/rest-core">Modular Ruby clients interface for REST APIs</a></li>
      <li>Middleware</li>
      <li><a href="https://github.com/godfat/rest-more">rest-more</a></li>
      <li>RC::Linkedin (via OAuth 1.0a)</li>
      <li>RC::Dropbox (via OAuth 1.0a)</li>
      <li>RC::Facebook (via OAuth 2, most completed)</li>
      <li>RC::Github (via OAuth 2)</li>
      <li>RC::Instagram (via OAuth 2)</li></ul>
</div></section>

<section class="slide"><div>
  <h2><a href="http://rubyconf.tw/2011/#6">RubyConf.TW 2011</a></h2>
  <ul><li>rest-core — <a href="https://github.com/godfat/rest-core">Modular Ruby clients interface for REST APIs</a></li>
      <li>Middleware</li>
      <li>RC::StackExchange (via OAuth 2)</li>
      <li>RC::Linkedin (via OAuth 1.0a)</li>
      <li>RC::Dropbox (via OAuth 1.0a)</li>
      <li>RC::Facebook (via OAuth 2, most completed)</li>
      <li>RC::Github (via OAuth 2)</li>
      <li>RC::Instagram (via OAuth 2)</li></ul>
</div></section>

<section class="slide"><div>
  <h2><a href="http://rubyconf.tw/2011/#6">RubyConf.TW 2011</a></h2>
  <ul><li>rest-core — <a href="https://github.com/godfat/rest-core">Modular Ruby clients interface for REST APIs</a></li>
      <li>RC::Twitter (via OAuth 1.0a)</li>
      <li>RC::StackExchange (via OAuth 2)</li>
      <li>RC::Linkedin (via OAuth 1.0a)</li>
      <li>RC::Dropbox (via OAuth 1.0a)</li>
      <li>RC::Facebook (via OAuth 2, most completed)</li>
      <li>RC::Github (via OAuth 2)</li>
      <li>RC::Instagram (via OAuth 2)</li></ul>
</div></section>

<section class="slide"><div>
  <h2><a href="http://rubyconf.tw/2011/#6">RubyConf.TW 2011</a></h2>
  <ul><li>TopCoder: <a href="https://github.com/miaout17/topcoder">topcoder</a></li>
      <li class="next">Plurk: <a href="https://github.com/brucehsu/s2sync_web">s2sync_web</a></li>
      <li class="next">YahooBuy: <a href="https://github.com/GoodLife/rest-more-yahoo_buy">rest-more-yahoo_buy</a></li>
      <li class="next">Firebase: <a href="https://github.com/CodementorIO/rest-firebase">rest-firebase</a></li></ul>
</div></section>

<section class="slide"><div>
  <h2><a href="http://rubyconf.tw/2012/">RubyConf.TW 2012</a></h2>
  <ul><li><a href="http://www.godfat.org/slide/2012-12-07-concurrent.pdf">Concurrent Ruby Application Servers</a></li>
      <li class="next">Linear/Mixed <a href="http://en.wikipedia.org/wiki/Data_dependency">data dependency</a></li>
      <li class="next">Callback/<a href="http://en.wikipedia.org/wiki/Futures_and_promises">Futures</a></li>
      <li class="next"><a href="http://en.wikipedia.org/wiki/CPU-bound">CPU</a> or <a href="http://en.wikipedia.org/wiki/I/O_bound#Comparison_with_CPU-bound">I/O</a> bound</li>
      <li class="next">Unicorn/<a href="http://rainbows.bogomips.org/">Rainbows!</a>/Thin/Puma</li></ul>
</div></section>

<section class="slide"><div>
  <h2>&nbsp;</h2>
  <ul><li>rest-core — <a href="https://github.com/godfat/rest-core">Modular Ruby clients interface for REST APIs</a></li>
      <li>(<span class="red">Middleware</span>) Modular interface for REST clients similar to WSGI/Rack for servers.</li>
      <li class="next">(<span class="red">Promises/Futures</span>) Concurrent requests with synchronous or asynchronous interfaces with threads.</li></ul>
</div></section>

<section class="slide"><div>
  <h2>&nbsp;</h2>
  <ul><li>rest-core — <a href="https://github.com/godfat/rest-core">Modular Ruby clients interface for REST APIs</a></li>
      <li>(<span class="red">Middleware</span>) Modular interface for REST clients similar to WSGI/Rack for servers.</li>
      <li>(<span class="red">Promises/Futures</span>) <span class="blue">Concurrent requests with synchronous or asynchronous interfaces with threads.</span></li></ul>
</div></section>

<section class="slide"><div>
  <h2>Table of Contents</h2>
  <ul><li>Introduction</li>
      <li class="red">The API / Use Cases</li>
      <li>Concurrency Model</li>
      <li>Streaming, the EventSource</li>
      <li>The Timeout Quest</li></ul>
</div></section>

<section class="slide"><div>
  <h2>The API / Use Cases</h2>
  <ul><li class="red">Futures / Synchronous / Blocking</li>
      <li>Callbacks / Asynchronous / Non-blocking</li>
      <li>Wait! It's not yet done</li>
      <li>Promise Chain: Promise#then</li>
      <li>Promise.claim</li></ul>
</div></section>

<section class="slide"><div>
  <h1>Futures / Synchronous / Blocking</h1>
  <h2>Print the Name</h2>
  <pre><code class="ruby">
puts client.get('ruby')['name']
  </code></pre>
</div></section>

<section class="slide"><div>
  <h1>Futures / Synchronous / Blocking</h1>
  <h2>Print the Names (Bad)</h2>
  <pre><code class="ruby">
puts client.get('ruby')<span class="highlight">['name']</span> # -- this blocks
puts client.get('opal')['name']</code></pre>
  <span class="next"><h2>Non-blocking (Better)</h2>
  <pre><code class="ruby">
puts %w[ruby opal].map{ |n| client.get(n) }.
                   map{ |r| r['name'] }</code></pre></span>
</div></section>

<section class="slide"><div>
  <h1>Futures / Synchronous / Blocking</h1>
  <h2>Or Easier to Read:</h2>
  <pre><code class="ruby">
a, b = client.get('ruby'), client.get('opal')
puts a['name'], b['name']</code></pre>
  <h2>Non-blocking (Better)</h2>
  <pre><code class="ruby">
puts %w[ruby opal].map{ |n| client.get(n) }.
                   map{ |r| r['name'] }</code></pre>
</div></section>

<section class="slide"><div>
  <h1>Futures / Synchronous / Blocking</h1>
  <h2>Fire and Forget</h2>
  <pre><code class="ruby">
client.post('ruby/cut', style: 'brilliant')</code></pre>
  <span class="next"><h2>Fire and Call</h2>
  <pre><code class="ruby">
client.post('ruby/cut', style: 'brilliant'){}</code></pre></span>
</div></section>

<section class="slide"><div>
  <h2>The API / Use Cases</h2>
  <ul><li>Futures / Synchronous / Blocking</li>
      <li class="red">Callbacks / Asynchronous / Non-blocking</li>
      <li>Wait! It's not yet done</li>
      <li>Promise Chain: Promise#then</li>
      <li>Promise.claim</li></ul>
</div></section>

<section class="slide"><div>
  <h1>Callbacks / Asynchronous / Non-blocking</h1>
  <h2>Fire and Call</h2>
  <pre><code class="ruby">
client.post('ruby/cut', style: 'brilliant'){}


</code></pre>
</div></section>

<section class="slide"><div>
  <h1>Callbacks / Asynchronous / Non-blocking</h1>
  <h2>Fire and Call</h2>
  <pre><code class="ruby">
client.post('ruby/cut', style: 'brilliant') do |r|
  puts r['status']
end</code></pre>
</div></section>

<section class="slide"><div>
  <h1>Callbacks / Asynchronous / Non-blocking</h1>
  <h2>Fire and Rescue</h2>
  <pre><code class="ruby">
client.post('ruby/cut', style: 'brilliant') do |r|
  puts r.kind_of?(Exception)
end</code></pre>
</div></section>

<section class="slide"><div>
  <h1>Callbacks / Asynchronous / Non-blocking</h1>
  <h2>Callback Hell?</h2>
  <pre><code class="ruby">
c = client
%w[ruby opal].each do |n|
  c.get("#{n}/friends") do |f|
    c.get("#{f.first['name']}/friends") do |ff|
      c.post("#{ff.first['name']}/mails", 'Hi')
    end
  end
end</code></pre>
</div></section>

<section class="slide"><div>
  <h1>Callbacks / Asynchronous / Non-blocking</h1>
  <h2>Callback Hell? Eliminate One</h2>
  <pre><code class="ruby">
c = client
%w[ruby opal].each do |n|
  c.get("#{n}/friends") do |f|
    ff = c.get("#{f.first['name']}/friends")
    c.post("#{ff.first['name']}/mails", 'Hi')
  end
end</code></pre>
</div></section>

<section class="slide"><div>
  <h1>Callbacks / Asynchronous / Non-blocking</h1>
  <h2>Callback Hell? But This Blocks!</h2>
  <pre><code class="ruby">
c = client
%w[ruby opal].map do |n|
  c.get("#{n}/friends")
end.map do |f|
  c.get("#{<span class="highlight">f.first</span>['name']}/friends")
end.map do |ff|
  c.post("#{ff.first['name']}/mails", 'Hi')
end</code></pre>
</div></section>

<section class="slide"><div>
  <h1>Callbacks / Asynchronous / Non-blocking</h1>
  <h2>We Still Need Callbacks</h2>
  <a href="http://www.godfat.org/slide/2012-12-07-concurrent.pdf"><img src="data-tmp-01.png" style="position:relative; top:-210px; left:-100px"></a>
</div></section>

<section class="slide"><div>
  <h2>The API / Use Cases</h2>
  <ul><li>Futures / Synchronous / Blocking</li>
      <li>Callbacks / Asynchronous / Non-blocking</li>
      <li class="red">Wait! It's not yet done</li>
      <li>Promise Chain: Promise#then</li>
      <li>Promise.claim</li></ul>
</div></section>

<section class="slide"><div>
  <h1>Wait! It's not yet done</h1>
  <h2>RC::Client#wait</h2>
  <pre><code class="ruby">
c = client
%w[ruby opal].each do |n|
  c.get("#{n}/friends") do |f|
    ff = c.get("#{f.first['name']}/friends")
    c.post("#{ff.first['name']}/mails", 'Hi')
  end
end


</code></pre>
</div></section>

<section class="slide"><div>
  <h1>Wait! It's not yet done</h1>
  <h2>RC::Client#wait</h2>
  <pre><code class="ruby">
r = []
%w[ruby opal].each do |n|
  c.get("#{n}/friends") do |f|
    ff = c.get("#{f.first['name']}/friends")
    r &lt;&lt; c.post("#{ff.first['name']}/mails", 'Hi')
  end
end
c.wait       # only for this client instance
puts r</code></pre>
</div></section>

<section class="slide"><div>
  <h1>Wait! It's not yet done</h1>
  <h2>RC::Client.wait</h2>
  <pre><code class="ruby">
r = []
%w[ruby opal].each do |n|
  c.get("#{n}/friends") do |f|
    ff = c.get("#{f.first['name']}/friends")
    r &lt;&lt; c.post("#{ff.first['name']}/mails", 'Hi')
  end
end
c.class.wait # for all requests from this class
puts r</code></pre>
</div></section>

<section class="slide"><div>
  <h1>Wait! It's not yet done</h1>
  <h2>RC::Client.wait</h2>
  <pre><code class="ruby">
r = []
%w[ruby opal].each do |n|
  c.get("#{n}/friends") do |f|
    ff = c.get("#{f.first['name']}/friends")
    r &lt;&lt; c.post("#{ff.first['name']}/mails", 'Hi')
  end
end
c.class.wait # useful for gracefully shutdown
puts r</code></pre>
</div></section>

<section class="slide"><div>
  <h2>The API / Use Cases</h2>
  <ul><li>Futures / Synchronous / Blocking</li>
      <li>Callbacks / Asynchronous / Non-blocking</li>
      <li>Wait! It's not yet done</li>
      <li class="red">Promise Chain: Promise#then</li>
      <li>Promise.claim</li></ul>
</div></section>

<section class="slide"><div>
  <h1>Promise Chain: Promise#then</h1>
  <h2>Without Waiting... Change This:</h2>
  <pre><code class="ruby">
r = []
%w[ruby opal].each do |n|
  c.get("#{n}/friends") do |f|
    ff = c.get("#{f.first['name']}/friends")
    r &lt;&lt; c.post("#{ff.first['name']}/mails", 'Hi')
  end
end
c.wait
puts r</code></pre>
</div></section>

<section class="slide"><div>
  <h1>Promise Chain: Promise#then</h1>
  <h2>Without Waiting... To This:</h2>
  <pre><code class="ruby">
r = %w[ruby opal].map do |n|
  c.get("#{n}/friends", {},
        RC::RESPONSE_KEY => RC::PROMISE).
        then do |res|
    f = res[RC::RESPONSE_BODY]
    ff = c.get("#{f.first['name']}/friends")
    st = c.post("#{ff.first['name']}/mails", 'Hi')
    res.merge(RC::RESPONSE_BODY => st)
  end.future_response[RC::RESPONSE_BODY]
end
puts r</code></pre>
</div></section>

<section class="slide"><div>
  <h1>Promise Chain: Promise#then</h1>
  <h2>Why: It's Not Blocking Here</h2>
  <pre><code class="ruby">
r = %w[ruby opal].map do |n|
  c.get("#{n}/friends", {},
        RC::RESPONSE_KEY => RC::PROMISE).
        then do |res|
    f = res[RC::RESPONSE_BODY]
    ff = c.get("#{f.first['name']}/friends")
    st = c.post("#{ff.first['name']}/mails", 'Hi')
    res.merge(RC::RESPONSE_BODY => st)
  end.future_response[RC::RESPONSE_BODY]
end
puts r</code></pre>
</div></section>

<section class="slide"><div>
  <pre class="fullscreen"><code class="ruby">
# <a href="https://github.com/godfat/rest-more/blob/rest-more-3.3.1/lib/rest-core/client/github.rb#L62-L78">RC::Github#all</a>

def all p, query={}, o={}
  q = {:per_page => MAX_PER_PAGE}.merge(query)
  r = <span class="highlight">get</span>(p, q, o.merge(RESPONSE_KEY => PROMISE)).
      then{ |res|
    b = res[RESPONSE_BODY] +
        page_range(res).<span class="highlight">map</span>{ |page|
          <span class="highlight">get</span>(p, q.merge(:page => page),
            o.merge(RESPONSE_KEY=>RESPONSE_BODY))
        }.inject([], &amp;:+)
    res.merge(RESPONSE_BODY => b)
  }.future_response
  if block_given?
    yield(r[response_key(o)]); self
  else
    r[response_key(o)]
  end
end</code></pre>
</div></section>

<section class="slide"><div>
  <h2>The API / Use Cases</h2>
  <ul><li>Futures / Synchronous / Blocking</li>
      <li>Callbacks / Asynchronous / Non-blocking</li>
      <li>Wait! It's not yet done</li>
      <li>Promise Chain: Promise#then</li>
      <li class="red">Promise.claim</li></ul>
</div></section>

<section class="slide"><div>
  <h1>Promise.claim</h1>
  <h2>Forging Response,<br>for middleware <code>RC::Cache</code></h2>
  <pre><code class="ruby">
RC::Promise.
  claim(res, k, body, 200, 'Header' => 'Here').
  future_response</code></pre>
</div></section>

<section class="slide"><div>
  <h1>Promise.claim</h1>
  <h2>Forging Response,<br>for middleware <code>RC::Cache</code></h2>
  <pre><code class="ruby">
def RC::Promise.claim env, k=RC.id,
                      body, status, headers
  promise = new(env, k)
  promise.fulfill(body, status, headers)
  promise
end</code></pre>
</div></section>

<section class="slide"><div>
  <h2>Table of Contents</h2>
  <ul><li>Introduction</li>
      <li>The API / Use Cases</li>
      <li class="red">Concurrency Model</li>
      <li>Streaming, the EventSource</li>
      <li>The Timeout Quest</li></ul>
</div></section>

<section class="slide"><div>
  <h2>Concurrency Model</h2>
  <ul><li class="red">None / Blocking (For debugging purpose)</li>
      <li>Thread Spawn (Default)</li>
      <li>Thread Pool (Throttling)</li></ul>
</div></section>

<section class="slide"><div>
  <h1>Concurrency Model</h1>
  <h2>None / Blocking<br>(For debugging purpose)</h2>
  <pre><code class="ruby">
RC::Universal.pool_size = -1</code></pre>
</div></section>

<section class="slide"><div>
  <h1>Concurrency Model - None / Blocking (For debugging purpose)</h1>
  <pre><code class="ruby">
def defer # RC::Promise#defer
  if pool_size &lt; 0
    # set working thread
    self.thread = Thread.current
    # set timeout
    env[TIMER].on_timeout{ cancel_task } if
      env[TIMER]
    # avoid any exception and do the job
    protected_yield{ yield }
  else
    # ...
  end
end</code></pre>
</div></section>

<section class="slide"><div>
  <pre class="fullscreen"><code class="ruby">
def cancel_task bt=nil # RC::Promise#cancel_task
  mutex.synchronize do
    next if done? # don't cancel if it's done
    if t = thread || task.thread
      # raise Timeout::Error to working thread
      t.raise(env[TIMER].error)
    else # task was queued and never started,
      begin # just cancel it and fulfil the
        task.cancel # promise with Timeout::Error
        rejecting(env[TIMER].error)
      rescue Exception => e
        # log user callback error
        callback_error(e) do
          e.set_backtrace(e.backtrace + (bt||[]))
        end
      end
    end
  end
end</code></pre>
</div></section>

<section class="slide"><div>
  <pre class="fullscreen"><code class="ruby">
def protected_yield # RC::Promise#protected_yield
  yield
rescue Exception => e # could be Timeout::Error
  mutex.synchronize do
    never_raise_yield do
      env[TIMER].cancel if env[TIMER]
      self.class.set_backtrace(e)
    end
    if done? # log user callback error
      callback_error(e)
    else # IOError, SystemCallError, etc
      begin
        rejecting(e) # would call user callback
      rescue Exception => f
        callback_error(f)# log user callback error
      end
    end
  end
end</code></pre>
</div></section>

<section class="slide"><div>
  <h2>Concurrency Model</h2>
  <ul><li>None / Blocking (For debugging purpose)</li>
      <li class="red">Thread Spawn (Default)</li>
      <li>Thread Pool (Throttling)</li></ul>
</div></section>

<section class="slide"><div>
  <h1>Concurrency Model</h1>
  <h2>Thread Spawn<br>(Default)</h2>
  <pre><code class="ruby">
RC::Universal.pool_size = 0</code></pre>
</div></section>

<section class="slide"><div>
  <h2>Concurrency Model</h2>
  <ul><li>None / Blocking (For debugging purpose)</li>
      <li>Thread Spawn (Default)</li>
      <li class="red">Thread Pool (Throttling)</li></ul>
</div></section>

<section class="slide"><div>
  <h1>Concurrency Model</h1>
  <h2>Thread Pool<br>(Throttling)</h2>
  <pre><code class="ruby">
RC::Universal.pool_size = 10</code></pre>
  <ul><li>For limited database/http connection</li></ul>
</div></section>

<section class="slide"><div>
  <h2>Table of Contents</h2>
  <ul><li>Introduction</li>
      <li>The API / Use Cases</li>
      <li>Concurrency Model</li>
      <li class="red">Streaming, the EventSource</li>
      <li>The Timeout Quest</li></ul>
</div></section>

<section class="slide"><div>
  <h2>Streaming, the EventSource</h2>
  <ul><li class="red">Server-Sent Events</li>
      <li>Rack Hijacking</li>
      <li>Firebase Daemon (rest-firebase)</li>
      <li>onreconnect Callback</li>
      <li>Wait! It's not yet done</li></ul>
</div></section>

<section class="slide"><div>
  <h2>Streaming, the EventSource</h2>
  <ul><li>Server-Sent Events</li>
      <li class="red">Rack Hijacking</li>
      <li>Firebase Daemon (rest-firebase)</li>
      <li>onreconnect Callback</li>
      <li>Wait! It's not yet done</li></ul>
</div></section>

<section class="slide"><div>
  <h2>Streaming, the EventSource</h2>
  <ul><li>Server-Sent Events</li>
      <li>Rack Hijacking</li>
      <li class="red">Firebase Daemon (rest-firebase)</li>
      <li>onreconnect Callback</li>
      <li>Wait! It's not yet done</li></ul>
</div></section>

<section class="slide"><div>
  <h2>Streaming, the EventSource</h2>
  <ul><li>Server-Sent Events</li>
      <li>Rack Hijacking</li>
      <li>Firebase Daemon (rest-firebase)</li>
      <li class="red">onreconnect Callback</li>
      <li>Wait! It's not yet done</li></ul>
</div></section>

<section class="slide"><div>
  <h2>Streaming, the EventSource</h2>
  <ul><li>Server-Sent Events</li>
      <li>Rack Hijacking</li>
      <li>Firebase Daemon (rest-firebase)</li>
      <li>onreconnect Callback</li>
      <li class="red">Wait! It's not yet done</li></ul>
</div></section>

<section class="slide"><div>
  <h2>Table of Contents</h2>
  <ul><li>Introduction</li>
      <li>The API / Use Cases</li>
      <li>Concurrency Model</li>
      <li>Streaming, the EventSource</li>
      <li class="red">The Timeout Quest</li></ul>
</div></section>

<section class="slide"><div>
  <h2>The Timeout Quest</h2>
  <ul><li class="red"><code>Thread#kill</code> is unsafe</li>
      <li><code>Thread#raise</code> is unsafe without masking</li>
      <li>The Timer Thread</li></ul>
</div></section>

<section class="slide"><div>
  <h2>The Timeout Quest</h2>
  <ul><li><code>Thread#kill</code> is unsafe</li>
      <li class="red"><code>Thread#raise</code> is unsafe without masking</li>
      <li>The Timer Thread</li></ul>
</div></section>

<section class="slide"><div>
  <h2>The Timeout Quest</h2>
  <ul><li><code>Thread#kill</code> is unsafe</li>
      <li><code>Thread#raise</code> is unsafe without masking</li>
      <li class="red">The Timer Thread</li></ul>
</div></section>

<section class="slide"><div>
  <h2>Bibliography</h2>
  <ul><li><a href="http://headius.blogspot.tw/2008/02/rubys-threadraise-threadkill-timeoutrb.html">Ruby's Thread#raise, Thread#kill, timeout.rb, and net/protocol.rb libraries are broken</a></li>
      <li><a href="http://chimera.labs.oreilly.com/books/1230000000929/ch09.html">Parallel and Concurrent Programming in Haskell: Chapter 9. Cancellation and Timeouts</a></li>
      <li><a href="http://www.w3.org/TR/eventsource/">Server-Sent Events</a></li>
      <li><a href="https://github.com/godfat/saya/commit/0bfb3bd470f70e20ca77d8cf3b47d1613c324a87">here's an example of SSE + hijack</a></li>
      <li><a href="http://www.meetup.com/rails-taiwan/events/219273897/">Rails Tuesday Sharing #8</a></li></ul>
</div></section>

<section class="slide shout"><div>
<h2>Q?</h2>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="https://github.com/godfat/rest-core">https://github.com/godfat/rest-core</a>
<br><br><br><br><br><br>
<pre><code class="ruby">
<span class="red">gem</span> <span class="string">install</span> <span class="constant">rest-core</span></code></pre>
</div></section>

  <div class="progress"><div></div></div>
  <script src="../asset/shower.min.js"></script>
  <script src='../asset/highlight.pack.js' type='text/javascript'></script>
  <script>hljs.initHighlightingOnLoad();</script>
</body>
</html>
